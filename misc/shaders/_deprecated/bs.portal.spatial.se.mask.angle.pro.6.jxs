<jittershader name="bs.portal.tex.proj.multi.direction.6-beam.jxs">
	<description>SPARCK - multi projection - Shader</description>
	<param name="mode" type="int" default="0" />
	<param name="stage_mode" type="int" default="0" />
	<param name="projection_mode" type="float" default="0" />

	<param name="cam0_pos" type="vec3" default="0. 0. 0." />
	<param name="cam0_v_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_p_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />

	<param name="beamer_enable" type="float" default="1. 1. 1. 1. 1. 1." />
	<param name="beamer_count" type="int" default="0" />

	<param name="beamer_color" type="vec4" default="1. 0. 0. 1. 0. 1. 0. 1. 0. 0. 1. 1. 0. 1. 1. 1. 1. 0. 1. 1. 1. 1. 0. 1." />
	<param name="offColor" type="vec4" default="0. 0. 0. 1." />

	<param name="beamer_pos" type="vec3" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_dir" type="vec3" default="0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1." />
	<param name="beamer_up" type="vec3" default="1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0." />

	<param name="beamer_m_matrix" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />
	<param name="beamer_v_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_p_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="world_matrix" type="mat4" state="WORLD_MATRIX" />
	<param name="viewport_matrix" type="mat4" default="0.5 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0.5 0. 0.5 0.5 0.5 0." />

	<param name="bevel_size" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="bevel_curve" type="float" default="1. 1. 1. 1. 1. 1." />
	<param name="bevel_round" type="int" default="0 0 0 0 0 0" />

	<param name="angle_mode" type="float" default="0.0" />

	<param name="angle_limit" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="angle_falloff" type="float" default="0.3 0.3 0.3 0.3 0.3 0.3" />
	<param name="angle_limit_low" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="angle_limit_high" type="float" default="0.2 0.2 0.2 0.2 0.2 0.2" />

	<param name="far_clip" type="float" default="0. 0. 0. 0. 0. 0." />

	<param name="blend_spread" type="float" default="1.0" />
	<param name="back_blend" type="float" default="1." />
	<param name="distance_influence" type="float" default="1." />

	<param name="interpolation_correction" type="float" default="0.1" />

	<param name="collada_factor" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />
	<param name="blend_power" type="float" default="1." />
	<param name="blend_luminance" type="float" default="1." />

	<param name="tex0" type="int" default="0" />
	<param name="tex1" type="int" default="1" />

	<language name="glsl" version="1.2">

		<bind param="beamer_count" program="fp" />
		<bind param="beamer_color" program="fp" />

		<bind param="beamer_pos" program="fp" />
		<bind param="beamer_dir" program="fp" />

		<bind param="projection_mode" program="fp" />
		<bind param="stage_mode" program="fp" />
		<bind param="mode" program="fp" />

		<bind param="blend_spread" program="fp" />
		<bind param="distance_influence" program="fp" />
		<bind param="angle_mode" program="fp" />

		<bind param="angle_limit_low" program="fp" />
		<bind param="angle_limit_high" program="fp" />

		<bind param="far_clip" program="fp" />

		<bind param="offColor" program="fp" />

		<bind param="world_matrix" program="vp" />
		<bind param="collada_factor" program="vp" />
		<bind param="interpolation_correction" program="fp" />

		<program name="vp" type="vertex">
<![CDATA[

// MIT License
// Martin Froehlich for tecartlab.com
// Copyright 2020 - tecartlab.com

#version 120

uniform mat4 world_matrix;
uniform mat4 collada_factor;

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position

mat4 screen_m_matrix = world_matrix * collada_factor;

void main(void)
{
	// perform required transform on vertex
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;

	normal = normalize(mat3(screen_m_matrix) * gl_Normal);
	worldPos = (screen_m_matrix * gl_Vertex).xyz;
}

]]>
		</program>

		<program name="fp" type="fragment">
<![CDATA[
#version 120
#extension GL_ARB_texture_rectangle : enable

/*
	Multifunctional texture projection shader with full feature set.
*/

uniform float projection_mode;
uniform int stage_mode;
uniform int mode;

uniform int beamer_count;
uniform vec4 beamer_color[6];

uniform vec3 beamer_pos[6];
uniform vec3 beamer_dir[6];

uniform vec4 offColor; 	// off color

uniform float distance_influence;
uniform float blend_spread;
uniform float angle_mode;

uniform float angle_limit_low[6];
uniform float angle_limit_high[6];

uniform float far_clip[6];

uniform float interpolation_correction;


// generated by the vertex shader

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position

float blendSpread = pow(((0.5 + (blend_spread)*10))*2., 4.);

// constants

const float PI = 3.1415926535897932384626433832795;
const float PI_HALF = PI / 2.0;
const vec4 WHITE = vec4( 1.0, 1.0, 1.0, 1.0);
const vec4 BLACK = vec4( 0.0, 0.0, 0.0, 1.0);

vec4 alphablend(vec4 src, vec4 dst){
	float outA = src.a + dst.a * (1.0 - src.a);
	return vec4((src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a))/outA, outA);
}

// entry point
void main()
{
	float 	vangle[6];
	float 	spreadedAngle[6];

	int   	indexSort[6];

	vec3 	ray, raynormal;
	vec2 	col;
	float 	angle, visible;
    int 	i, j;

  	for( i = 0; i < 6; i++){
		vangle[i] = 0.0;
		spreadedAngle[i] = 0.0;
		indexSort[i] = i;
	}

    //Calculating the factor of importance for each beamer
	for( i = 0; i < beamer_count; i++){
		// calculate the viewray from the camera to this fragment
		ray = beamer_pos[i] - worldPos;
		raynormal = normalize(ray);

		// calculate the angle between the surface normal and the projected beam.
		// 		rsp. the angle between the surface normal and the projector direction.
		angle = dot(normal, raynormal * (1.0 - angle_mode) + beamer_dir[i] * angle_mode);

		// checks if the worldPos is in front of the camera.
		//   the interpolation_correction factor is making sure that fragment
		//   interpolation errors will be cut away, with the negative
		//   sideeffect of less total angle visibility.
		angle = angle * max(sign(dot(beamer_dir[i],raynormal)-interpolation_correction), 0.);

		// sets from which side (back, both, front) it is visible
		angle = (projection_mode == 0.)? abs(angle):angle * projection_mode;

		// it calculates the relation between the distance and the far clip
		angle *= min(1.0, 1.0 - distance_influence * length(ray) / far_clip[i]);

		//calculates the visibility factor for the angle;
		visible = smoothstep(angle_limit_low[i], angle_limit_high[i], angle);

		vangle[i] = angle * visible;
	}

	//Sorting the viewport values
	int idxmax;

    for(i = (beamer_count - 1); i > 0; --i){
    	for(j = 0; j < i; j++){
	    	idxmax = (vangle[indexSort[j]] > vangle[indexSort[j+1]])? indexSort[j]: indexSort[j + 1];
    		indexSort[j + 1] = indexSort[j] + indexSort[j + 1] - idxmax;
    		indexSort[j] = idxmax;
    	}
    }

	//spread the angles and calc the blend factor for each of the four possible beams
	spreadedAngle[indexSort[0]] = vangle[indexSort[0]];
	spreadedAngle[indexSort[1]] = vangle[indexSort[1]] * pow((1. - vangle[indexSort[0]] + vangle[indexSort[1]]), blendSpread);
	spreadedAngle[indexSort[2]] = vangle[indexSort[2]] * pow((1. - vangle[indexSort[0]] + vangle[indexSort[2]]), blendSpread);
	spreadedAngle[indexSort[3]] = vangle[indexSort[3]] * pow((1. - vangle[indexSort[0]] + vangle[indexSort[3]]), blendSpread);

	float sumAngle = spreadedAngle[indexSort[0]] + spreadedAngle[indexSort[1]] + spreadedAngle[indexSort[2]] + spreadedAngle[indexSort[3]];

	// normalizing the blend factors for the first time
	// and multiply it with the curve.
	float normalizeOne = 1.0 / sumAngle;
	spreadedAngle[indexSort[0]] *= normalizeOne;
	spreadedAngle[indexSort[1]] *= normalizeOne;
	spreadedAngle[indexSort[2]] *= normalizeOne;
	spreadedAngle[indexSort[3]] *= normalizeOne;

	// calculate the mode
	if(mode == 0){
		// it is drawn inside the 3dviewer

		// calculate the color mode
		if(stage_mode <= 1){
			// create the colormix with up to 4 beamers
			vec4 col = beamer_color[indexSort[0]] * spreadedAngle[indexSort[0]];
			col += beamer_color[indexSort[1]] * spreadedAngle[indexSort[1]];
			col += beamer_color[indexSort[2]] * spreadedAngle[indexSort[2]];
			col += beamer_color[indexSort[3]] * spreadedAngle[indexSort[3]];
			gl_FragColor = alphablend(col, offColor);
		//gl_FragColor = beamer_color[indexSort[0]];
		} else if(stage_mode == 2){
			// create the colormix with up to 4 beamers
			gl_FragColor =  WHITE - vec4(0.2, 0.2, 0.2, 0.0);
		} else if(stage_mode == 3){
			// create the colormix with up to 4 beamers
			gl_FragColor =  beamer_color[indexSort[0]] * vangle[indexSort[0]] +
							beamer_color[indexSort[1]] * vangle[indexSort[1]] +
							beamer_color[indexSort[2]] * vangle[indexSort[2]] +
							beamer_color[indexSort[3]] * vangle[indexSort[3]];
		} else if(stage_mode > 3){
			// create the colormix with up to 4 beamers
			gl_FragColor = vec4(beamer_color[stage_mode - 4].rgb * spreadedAngle[stage_mode - 4], 1.);
		}
	} else if(mode > 0){
		// it has to output a mask
		gl_FragColor = vec4(spreadedAngle[mode - 1], spreadedAngle[mode - 1], spreadedAngle[mode - 1], 1.);
	}

}

]]>
		</program>
	</language>
</jittershader>
