<jittershader name="bs.portal.tex.proj.multi.direction.6-beam.jxs">
	<description>SPARCK - multi projection - Shader</description>
	<param name="tex0" type="int" default="0" />
	<param name="tex1" type="int" default="1" />
	<param name="tex2" type="int" default="2" />
	<param name="tex3" type="int" default="3" />
	<param name="tex4" type="int" default="4" />
	<param name="tex5" type="int" default="5" />
	<param name="tex6" type="int" default="6" />
	<param name="tex7" type="int" default="7" />

	<param name="mode" type="int" default="0" />
	<param name="stage_mode" type="int" default="0" />
	<param name="projection_mode" type="float" default="0" />

	<param name="cam0_pos" type="vec3" default="0. 0. 0." />
	<param name="cam0_v_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_p_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />

	<param name="beamer_enable" type="float" default="1. 1. 1. 1. 1. 1." />
	<param name="beamer_count" type="int" default="0" />

	<param name="beamer_color" type="vec4" default="1. 0. 0. 1. 0. 1. 0. 1. 0. 0. 1. 1. 0. 1. 1. 1. 1. 0. 1. 1. 1. 1. 0. 1." />
	<param name="offColor" type="vec4" default="0. 0. 0. 1." />

	<param name="beamer_pos" type="vec3" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_dir" type="vec3" default="0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1." />
	<param name="beamer_up" type="vec3" default="1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0." />

	<param name="beamer_m_matrix" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />
	<param name="beamer_v_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_p_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="world_matrix" type="mat4" state="WORLD_MATRIX" />
	<param name="viewport_matrix" type="mat4" default="0.5 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0.5 0. 0.5 0.5 0.5 0." />

	<param name="bevel_size" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="bevel_curve" type="float" default="1. 1. 1. 1. 1. 1." />
	<param name="bevel_round" type="int" default="0 0 0 0 0 0" />

	<param name="angle_mode" type="float" default="0.0" />

	<param name="angle_limit" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="angle_falloff" type="float" default="0.3 0.3 0.3 0.3 0.3 0.3" />
	<param name="angle_limit_low" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="angle_limit_high" type="float" default="0.2 0.2 0.2 0.2 0.2 0.2" />

	<param name="far_clip" type="float" default="0. 0. 0. 0. 0. 0." />

	<param name="blend_spread" type="float" default="1.0" />
	<param name="back_blend" type="float" default="1." />
	<param name="distance_influence" type="float" default="1." />

	<param name="interpolation_correction" type="float" default="0.1" />

	<param name="gradient" type="float" default="0. 0.024453 0.048907 0.07336 0.097813 0.122267 0.14672 0.171173 0.195627 0.22008 0.244533 0.268987 0.29344 0.31509 0.329438 0.343786 0.358133 0.372481 0.386829 0.401176 0.415524 0.429871 0.441664 0.449133 0.456602 0.464072 0.471541 0.47901 0.48648 0.493949 0.501418 0.508887 0.514397 0.519075 0.523754 0.528432 0.533111 0.53779 0.542468 0.547147 0.551825 0.556504 0.561149 0.563628 0.566107 0.568586 0.571065 0.573544 0.576023 0.578502 0.580981 0.58346 0.585939 0.588418 0.596003 0.604785 0.613568 0.622351 0.631133 0.639916 0.648698 0.657481 0.666263 0.675046 0.683828 0.692611 0.701393 0.710176 0.718958 0.727741 0.736524 0.745306 0.754089 0.762871 0.771654 0.780436 0.789219 0.798001 0.806784 0.815567 0.824349 0.833132 0.841914 0.850697 0.859479 0.868262 0.877044 0.885827 0.894609 0.903392 0.912175 0.920957 0.92974 0.938522 0.947305 0.956087 0.96487 0.973652 0.982435 0.991217 1." />
	<param name="blend_power" type="float" default="2.1" />
	<param name="blend_luminance" type="float" default="0.68" />
	<param name="collada_factor" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />

	<language name="glsl" version="1.2">
		<bind param="tex0" program="fp" />
		<bind param="tex1" program="fp" />
		<bind param="tex2" program="fp" />
		<bind param="tex3" program="fp" />
		<bind param="tex4" program="fp" />
		<bind param="tex5" program="fp" />
		<bind param="tex6" program="fp" />
		<bind param="tex7" program="fp" />

		<bind param="beamer_count" program="fp" />
		<bind param="beamer_color" program="fp" />

		<bind param="projection_mode" program="fp" />
		<bind param="stage_mode" program="fp" />
		<bind param="mode" program="fp" />

		<bind param="offColor" program="fp" />

		<bind param="blend_power" program="fp" />
		<bind param="blend_luminance" program="fp" />
		<bind param="gradient" program="fp" />

		<bind param="viewport_matrix" program="vp" />
		<bind param="world_matrix" program="vp" />
		<bind param="collada_factor" program="vp" />

		<bind param="cam0_v_matrix" program="vp" />
		<bind param="cam0_p_matrix" program="vp" />

		<program name="vp" type="vertex">
<![CDATA[

// MIT License
// Martin Froehlich for tecartlab.com
// Copyright 2020 - tecartlab.com

#version 120

uniform mat4 cam0_v_matrix;
uniform mat4 cam0_p_matrix;

uniform mat4 viewport_matrix;
uniform mat4 world_matrix;
uniform mat4 collada_factor;

varying vec2 texcoord2;

varying vec2 custom_texcoord;
varying vec4 camera_uv[1];		// camera uv position
varying vec2 camera_texcoord[1];// beamer texcoord

mat4 screen_m_matrix = world_matrix * collada_factor;

mat4 mvp0_matrix =  cam0_p_matrix * cam0_v_matrix * screen_m_matrix;

void main(void)
{
	// perform standard transform on vertex
	gl_Position = ftransform();

	// apply the UV to texturcoordinate for the custom texture
    custom_texcoord = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);

	// calculate the UV-coordinate for camera 0
	vec4 clip0 = vec4(mvp0_matrix * gl_Vertex);
	vec4 device0 = vec4(clip0.x / clip0.w, clip0.y / clip0.w, clip0.z / clip0.w, 1.);
	vec4 screen0 = viewport_matrix * device0;
	camera_uv[0] = vec4(screen0.x, screen0.y, 0., 1.);

	// apply the UV to texturcoordinate for cam0
	camera_texcoord[0] = vec2(gl_TextureMatrix[1] * camera_uv[0]);

 	texcoord2 = vec2(gl_TextureMatrix[2] * gl_MultiTexCoord2);
}

]]>
		</program>

		<program name="fp" type="fragment">
<![CDATA[
#version 120
#extension GL_ARB_texture_rectangle : enable

/*
	Multifunctional texture projection shader with full feature set.
*/

uniform float projection_mode;
uniform int stage_mode;
uniform int mode;

// samplers
uniform sampler2DRect tex0;
uniform sampler2DRect tex1;
uniform sampler2DRect tex2;
uniform sampler2DRect tex3;
uniform sampler2DRect tex4;
uniform sampler2DRect tex5;
uniform sampler2DRect tex6;
uniform sampler2DRect tex7;

uniform int beamer_count;

uniform vec4 beamer_color[6];

uniform vec4 offColor; 	// off color

uniform float gradient[101];
uniform float blend_power;
uniform float blend_luminance;

varying vec2 texcoord2;

// generated by the vertex shader
varying vec2 custom_texcoord;
varying vec4 camera_uv[1];		// camera uv position
varying vec2 camera_texcoord[1];// beamer texcoord


// constants

const float PI = 3.1415926535897932384626433832795;
const float PI_HALF = PI / 2.0;
const vec4 WHITE = vec4( 1.0, 1.0, 1.0, 1.0);
const vec4 BLACK = vec4( 0.0, 0.0, 0.0, 1.0);

vec4 alphablend(vec4 src, vec4 dst){
	float outA = src.a + dst.a * (1.0 - src.a);
	return vec4((src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a))/outA, outA);
}

float softedgeblend(float _factor){
	// calculate alpha blend channel
	return (_factor < 0.5)?
			blend_luminance * pow((2. * _factor), blend_power):
			1. - (1. - blend_luminance) * pow(2. * (1. - _factor), blend_power);
}

// entry point
void main()
{

	vec4 color[6];
	color[0] = texture2DRect(tex2, texcoord2);
	color[1] = texture2DRect(tex3, texcoord2);
	color[2] = texture2DRect(tex4, texcoord2);
	color[3] = texture2DRect(tex5, texcoord2);
	color[4] = texture2DRect(tex6, texcoord2);
	color[5] = texture2DRect(tex7, texcoord2);

	// calculate the mode
	if(mode == 0){
		// it is drawn inside the 3dviewer

		// calculate the color mode
		if(stage_mode <= 3){
			// create the colormix
			vec4 col = vec4(0., 0., 0., 0.);
			for(int i = 0; i < beamer_count; i++){
				col += beamer_color[i] * color[i];
			}
			gl_FragColor = col;
		} else if(stage_mode > 3){
			// create the colormix with up to 4 beamers
			//gl_FragColor = vec4(color[stage_mode - 4].rgb, 1.);
			//gl_FragColor = vec4((color[stage_mode - 4].a > 0)?color[stage_mode - 4].rgb:vec3(0., 0., 0.), 1.);
			gl_FragColor = vec4(texture2DRect(tex1, camera_texcoord[0]).rgb * color[stage_mode - 4].r, 1);
		}
	} else if(mode > 0){
		vec4 projectedColor;
		float gradientCorrected = softedgeblend(gradient[int(color[mode - 1].r * 100.)]);

	//	gl_FragColor = alphablend(vec4(texture2DRect(tex1, camera_texcoord[0]).rgb, gradientCorrected), texture2DRect(tex0, custom_texcoord));
		gl_FragColor = vec4(texture2DRect(tex1, camera_texcoord[0]).rgb, gradientCorrected);
	}

}

]]>
		</program>
	</language>
</jittershader>
